#include "i2c_connection.h"
#include <hal/i2c_types.h>
#include <stdint.h>
#include <string.h>

static const uint8_t font5x7[][5] = {
    // ' '
    {0x00, 0x00, 0x00, 0x00, 0x00},
    // !
    {0x00, 0x00, 0x5D, 0x00, 0x00},
    // "
    {0x00, 0x07, 0x00, 0x07, 0x00},
    // #
    {0x14, 0x3E, 0x14, 0x3E, 0x14},
    // $
    {0x24, 0x2A, 0x7F, 0x2A, 0x12},
    // %
    {0x23, 0x13, 0x08, 0x64, 0x62},
    // &
    {0x36, 0x49, 0x55, 0x22, 0x50},
    // '
    {0x00, 0x05, 0x03, 0x00, 0x00},
    // (
    {0x00, 0x1C, 0x22, 0x41, 0x00},
    // )
    {0x00, 0x41, 0x22, 0x1C, 0x00},
    // *
    {0x14, 0x08, 0x3E, 0x08, 0x14},
    // +
    {0x08, 0x08, 0x3E, 0x08, 0x08},
    // ,
    {0x00, 0x50, 0x30, 0x00, 0x00},
    // -
    {0x08, 0x08, 0x08, 0x08, 0x08},
    // .
    {0x00, 0x60, 0x60, 0x00, 0x00},
    // /
    {0x20, 0x10, 0x08, 0x04, 0x02},

    // 0
    {0x3E, 0x51, 0x49, 0x45, 0x3E},
    // 1
    {0x00, 0x42, 0x7F, 0x40, 0x00},
    // 2
    {0x42, 0x61, 0x51, 0x49, 0x46},
    // 3
    {0x21, 0x41, 0x45, 0x4B, 0x31},
    // 4
    {0x18, 0x14, 0x12, 0x7F, 0x10},
    // 5
    {0x27, 0x45, 0x45, 0x45, 0x39},
    // 6
    {0x3C, 0x4A, 0x49, 0x49, 0x30},
    // 7
    {0x01, 0x71, 0x09, 0x05, 0x03},
    // 8
    {0x36, 0x49, 0x49, 0x49, 0x36},
    // 9
    {0x06, 0x49, 0x49, 0x29, 0x1E},

    // :
    {0x00, 0x36, 0x36, 0x00, 0x00},
    // ;
    {0x00, 0x56, 0x36, 0x00, 0x00},
    // <
    {0x08, 0x14, 0x22, 0x41, 0x00},
    // =
    {0x14, 0x14, 0x14, 0x14, 0x14},
    // >
    {0x00, 0x41, 0x22, 0x14, 0x08},
    // ?
    {0x02, 0x01, 0x51, 0x09, 0x06},
    // @
    {0x32, 0x49, 0x79, 0x41, 0x3E},

    // A
    {0x7C, 0x12, 0x11, 0x12, 0x7C},
    // B
    {0x7F, 0x49, 0x49, 0x49, 0x36},
    // C
    {0x3E, 0x41, 0x41, 0x41, 0x22},
    // D
    {0x7F, 0x41, 0x41, 0x22, 0x1C},
    // E
    {0x7F, 0x49, 0x49, 0x49, 0x41},
    // F
    {0x7F, 0x09, 0x09, 0x09, 0x01},
    // G
    {0x3E, 0x41, 0x49, 0x49, 0x7A},
    // H
    {0x7F, 0x08, 0x08, 0x08, 0x7F},
    // I
    {0x00, 0x41, 0x7F, 0x41, 0x00},
    // J
    {0x20, 0x40, 0x41, 0x3F, 0x01},
    // K
    {0x7F, 0x08, 0x14, 0x22, 0x41},
    // L
    {0x7F, 0x40, 0x40, 0x40, 0x40},
    // M
    {0x7F, 0x02, 0x0C, 0x02, 0x7F},
    // N
    {0x7F, 0x04, 0x08, 0x10, 0x7F},
    // O
    {0x3E, 0x41, 0x41, 0x41, 0x3E},
    // P
    {0x7F, 0x09, 0x09, 0x09, 0x06},
    // Q
    {0x3E, 0x41, 0x51, 0x21, 0x5E},
    // R
    {0x7F, 0x09, 0x19, 0x29, 0x46},
    // S
    {0x46, 0x49, 0x49, 0x49, 0x31},
    // T
    {0x01, 0x01, 0x7F, 0x01, 0x01},
    // U
    {0x3F, 0x40, 0x40, 0x40, 0x3F},
    // V
    {0x1F, 0x20, 0x40, 0x20, 0x1F},
    // W
    {0x7F, 0x20, 0x18, 0x20, 0x7F},
    // X
    {0x63, 0x14, 0x08, 0x14, 0x63},
    // Y
    {0x03, 0x04, 0x78, 0x04, 0x03},
    // Z
    {0x61, 0x51, 0x49, 0x45, 0x43},

    // [
    {0x00, 0x7F, 0x41, 0x41, 0x00},
    // ' \'
    {0x02, 0x04, 0x08, 0x10, 0x20},
    // ]
    {0x00, 0x41, 0x41, 0x7F, 0x00},
    // ^
    {0x04, 0x02, 0x01, 0x02, 0x04},
    // _
    {0x40, 0x40, 0x40, 0x40, 0x40},
    // `
    {0x00, 0x01, 0x02, 0x04, 0x00},

    // a
    {0x20, 0x54, 0x54, 0x54, 0x78},
    // b
    {0x7F, 0x48, 0x44, 0x44, 0x38},
    // c
    {0x38, 0x44, 0x44, 0x44, 0x20},
    // d
    {0x38, 0x44, 0x44, 0x48, 0x7F},
    // e
    {0x38, 0x54, 0x54, 0x54, 0x18},
    // f
    {0x08, 0x7E, 0x09, 0x01, 0x02},
    // g
    {0x0C, 0x52, 0x52, 0x52, 0x3E},
    // h
    {0x7F, 0x08, 0x04, 0x04, 0x78},
    // i
    {0x00, 0x44, 0x7D, 0x40, 0x00},
    // j
    {0x20, 0x40, 0x44, 0x3D, 0x00},
    // k
    {0x7F, 0x10, 0x28, 0x44, 0x00},
    // l
    {0x00, 0x41, 0x7F, 0x40, 0x00},
    // m
    {0x7C, 0x04, 0x18, 0x04, 0x78},
    // n
    {0x7C, 0x08, 0x04, 0x04, 0x78},
    // o
    {0x38, 0x44, 0x44, 0x44, 0x38},
    // p
    {0x7C, 0x14, 0x14, 0x14, 0x08},
    // q
    {0x08, 0x14, 0x14, 0x18, 0x7C},
    // r
    {0x7C, 0x08, 0x04, 0x04, 0x08},
    // s
    {0x48, 0x54, 0x54, 0x54, 0x20},
    // t
    {0x04, 0x3F, 0x44, 0x40, 0x20},
    // u
    {0x3C, 0x40, 0x40, 0x20, 0x7C},
    // v
    {0x1C, 0x20, 0x40, 0x20, 0x1C},
    // w
    {0x3C, 0x40, 0x30, 0x40, 0x3C},
    // x
    {0x44, 0x28, 0x10, 0x28, 0x44},
    // y
    {0x0C, 0x50, 0x50, 0x50, 0x3C},
    // z
    {0x44, 0x64, 0x54, 0x4C, 0x44},

    // {
    {0x00, 0x08, 0x36, 0x41, 0x00},
    // |
    {0x00, 0x00, 0x7F, 0x00, 0x00},
    // }
    {0x00, 0x41, 0x36, 0x08, 0x00},
    // ~
    {0x08, 0x04, 0x08, 0x10, 0x08},
};

#define SSD1306_WIDTH 128
#define SSD1306_HEIGHT 64
#define SSD1306_PAGES (SSD1306_HEIGHT / 8)

static uint8_t fb[SSD1306_WIDTH * SSD1306_PAGES];

static void initial_commands(screen_t *screen) {
  ssd1306_command(0xAE, screen); // display off
  ssd1306_command(0xD5, screen); // clock
  ssd1306_command(0x80, screen);

  ssd1306_command(0xA8, screen); // multiplex
  ssd1306_command(0x3F, screen); // 64 rows

  ssd1306_command(0xD3, screen); // display offset
  ssd1306_command(0x00, screen);

  ssd1306_command(0x40, screen); // start line

  ssd1306_command(0x8D, screen); // charge pump
  ssd1306_command(0x14, screen);

  ssd1306_command(0x20, screen); // memory mode
  ssd1306_command(0x00, screen); // horizontal

  ssd1306_command(0xA1, screen); // segment remap
  ssd1306_command(0xC8, screen); // COM scan dir

  ssd1306_command(0xDA, screen); // COM pins
  ssd1306_command(0x12, screen);

  ssd1306_command(0x81, screen); // contrast
  ssd1306_command(0x7F, screen);

  ssd1306_command(0xAF, screen); // display ON
}

void init(int sda, int scl, screen_t *screen) {
  init_bus(sda, scl, screen);

  initial_commands(screen);
}

esp_err_t horizontale_flip(screen_t *screen,
                           uint8_t direction) // 1:normal , 0:mirrored
{
  if (direction != 0 && direction != 1) {
    return ESP_ERR_INVALID_ARG;
  }
  ssd1306_command((0xA0 + direction), screen);
  return ESP_OK;
}

esp_err_t vertical_flip(screen_t *screen, uint8_t direction) {
  if (direction != 0 && direction != 1) {
    return -1;
  }
  ssd1306_command((direction ? 0xC0 : 0xC8), screen);
  return ESP_OK;
}

esp_err_t set_brightness(screen_t *screen, uint8_t brightness) {
  if (brightness > 7) {
    return ESP_ERR_INVALID_ARG;
  }

  ssd1306_command(0x81, screen);
  ssd1306_command(((brightness + 1) * 15 + brightness), screen);

  return ESP_OK;
}

void ssd1306_draw_pixel(int x, int y, int color) {
  if (x < 0 || x >= SSD1306_WIDTH || y < 0 || y >= SSD1306_HEIGHT)
    return;

  int page = y / 8;
  int bit = y % 8;
  int index = x + page * SSD1306_WIDTH;

  if (color == 1)
    fb[index] |= (1 << bit);
  else
    fb[index] &= ~(1 << bit);
}

void ssd1306_clear_fb(void) { memset(fb, 0x00, sizeof(fb)); }

void ssd1306_update(screen_t *screen) {
  for (uint8_t page = 0; page < SSD1306_PAGES; page++) {
    ssd1306_command(0xB0 + page, screen); // page address
    ssd1306_command(0x00, screen);        // lower column
    ssd1306_command(0x10, screen);        // higher column

    ssd1306_data(&fb[page * SSD1306_WIDTH], SSD1306_WIDTH, screen);
  }
}

void ssd1306_draw_horizental_line(int x, int y, int length, int thikness,
                                  int color) {
  for (int i = 0; i < thikness; i++) {
    for (int j = 0; j < length; j++) {
      if (color == 1)
        ssd1306_draw_pixel(x + j, y + i, 1);
    }
  }
}

void ssd1306_draw_verticale_line(int x, int y, int length, int thikness,
                                 int color) {
  for (int i = 0; i < thikness; i++) {
    for (int j = 0; j < length; j++) {
      ssd1306_draw_pixel(x + i, y + j, 1);
    }
  }
}

void ssd1306_draw_rectangle_empty(int x, int y, int hight, int width) {
  for (int i = 0; i < hight; i++) {
    if (i == 0) {
      ssd1306_draw_horizental_line(x, y, width, 1, 1);
    } else if (i == hight - 1) {
      ssd1306_draw_horizental_line(x, y + hight, width, 1, 1);
    } else {
      for (int j = 0; j < width; j++) {
        ssd1306_draw_pixel(x + j, y + i, (j == 0 || j == width - 1) ? 1 : 0);
      }
    }
  }
}

void draw_char(int x, int y, char c, int scale,int color) {
  if (c < 32 || c > 126 || scale < 1)
    return;


  const uint8_t *chara = font5x7[c - 32];

  for (int col = 0; col < 5; col++) {
    uint8_t bits = chara[col];

    for (int row = 0; row < 7; row++) {
      if (bits & (1 << row)) {
        for (int dx = 0; dx < scale; dx++) {
          for (int dy = 0; dy < scale; dy++) {
            ssd1306_draw_pixel(x + col * scale + dx, y + row * scale + dy, color);
          }
        }
      }
    }
  }
}

void draw_string(int x, int y, char *str, int scale,int color) {

  while (*str) {
    draw_char(x, y, *str++, scale,color);

    x += 6 * scale;
  }
}

